---
title: "两种网络设计模式Proactor 和 Reactor"
date: 2016-03-17 04:26:54
keywords: "设计模式, Proactor, Reactor"
categories:
  - 设计模式
tags:
  - 转载
  - 技术文档
  - 架构
---

Proactor这个模式是从Boost.Asio中的异步事件模型了解到的，一直都在用Asio异步网络框架却一直没了解它的底层，一度以为异步网络框架就只有这种接收到数据异步回调的方式，直到今天才了解到还有一种Reactor模式（其实EPOLL采用的是这种模式，一直只会用不了解）。

<!-- more -->

关于Proactor和Reactor模式主要的区别简单归结可以做如下比喻：

* Reactor：孩子该吃饭了，您可以去厨房拿菜做饭给孩子吃了。

* Proactor：孩子该吃饭了，按您的吩咐把饭菜做给孩子吃了，孩子已经吃完饭了。



简单来说也就是Reactor模式关注就绪事件，比如孩子该吃饭了，具体要怎么做（去做饭给孩子吃）是你需要具体实施的；而Proactor关注完成事件，比如孩子该吃饭了，你事先通知保姆做什么饭，喂给孩子吃之后再通知我。



Reactor 和 Proactor 是两种高性能的设计模式，相对于直接读写，方便太多了。



下面转载了一篇写得比较好的文章 [原文链接](http://www.cnblogs.com/dawen/archive/2011/05/18/2050358.html)



> 两种I/O多路复用模式：Reactor和Proactor

> 

> 一般地,I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。两个与事件分离器有关的模式是Reactor和Proactor。Reactor模式采用同步IO，而Proactor采用异步IO。

> 

> 在Reactor中，事件分离器负责等待文件描述符或socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。

> 

> 而在Proactor模式中，处理器--或者兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从socket读到的数据。事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。

> 

> 举个例子，将有助于理解Reactor与Proactor二者的差异，以读操作为例（类操作类似）。

> 在Reactor中实现读：

> 

> - 注册读就绪事件和相应的事件处理器

> - 事件分离器等待事件

> - 事件到来，激活分离器，分离器调用事件对应的处理器。

> - 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。

> 在Proactor中实现读：

> 

> - 处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。

> - 事件分离器等待操作完成事件

> - 在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。

> - 事件分离器呼唤处理器。

> - 事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。

> 

> 可以看出，两个模式的相同点，都是对某个IO事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。

